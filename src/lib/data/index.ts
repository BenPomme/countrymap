import type { Country, CountryFilters } from '@/types/country'
import { getNestedValue } from '@/lib/utils'

// Import static data (will be generated by fetch script)
import countriesData from '../../../data/countries.json'

export function getAllCountries(): Country[] {
  return countriesData as Country[]
}

export function getCountryByCode(iso3: string): Country | undefined {
  return getAllCountries().find((c) => c.iso3 === iso3)
}

export function filterCountries(
  countries: Country[],
  filters: CountryFilters
): Country[] {
  return countries.filter((country) => {
    // Religion filter
    if (filters.majorReligion && filters.majorReligion.length > 0) {
      if (!filters.majorReligion.includes(country.religion.major)) {
        return false
      }
    }

    // Democracy score filter
    if (filters.democracyMin !== undefined) {
      if (country.democracy.score < filters.democracyMin) return false
    }
    if (filters.democracyMax !== undefined) {
      if (country.democracy.score > filters.democracyMax) return false
    }

    // GDP per capita filter
    if (filters.gdpMin !== undefined) {
      if (!country.poverty.gdpPerCapita || country.poverty.gdpPerCapita < filters.gdpMin) {
        return false
      }
    }
    if (filters.gdpMax !== undefined) {
      if (!country.poverty.gdpPerCapita || country.poverty.gdpPerCapita > filters.gdpMax) {
        return false
      }
    }

    // Poverty rate filter
    if (filters.povertyMin !== undefined) {
      if (country.poverty.povertyRate === null || country.poverty.povertyRate < filters.povertyMin) {
        return false
      }
    }
    if (filters.povertyMax !== undefined) {
      if (country.poverty.povertyRate === null || country.poverty.povertyRate > filters.povertyMax) {
        return false
      }
    }

    // Conflict filter
    if (filters.hasConflict !== undefined) {
      if (country.conflict.hasActiveConflict !== filters.hasConflict) {
        return false
      }
    }

    // Gender equality filter
    if (filters.genderMin !== undefined) {
      if (!country.gender.wblIndex || country.gender.wblIndex < filters.genderMin) {
        return false
      }
    }
    if (filters.genderMax !== undefined) {
      if (!country.gender.wblIndex || country.gender.wblIndex > filters.genderMax) {
        return false
      }
    }

    // Region filter
    if (filters.regions && filters.regions.length > 0) {
      if (!filters.regions.includes(country.region)) {
        return false
      }
    }

    return true
  })
}

export function getUniqueReligions(countries: Country[]): string[] {
  const religions = new Set<string>()
  countries.forEach((c) => {
    if (c.religion.major) {
      religions.add(c.religion.major)
    }
  })
  return Array.from(religions).sort()
}

export function getUniqueRegions(countries: Country[]): string[] {
  const regions = new Set<string>()
  countries.forEach((c) => {
    if (c.region) {
      regions.add(c.region)
    }
  })
  return Array.from(regions).sort()
}

export function getValueRange(
  countries: Country[],
  path: string
): { min: number; max: number } {
  const values = countries
    .map((c) => getNestedValue(c as unknown as Record<string, unknown>, path) as number)
    .filter((v) => v !== null && v !== undefined && !isNaN(v))

  if (values.length === 0) {
    return { min: 0, max: 100 }
  }

  return {
    min: Math.min(...values),
    max: Math.max(...values),
  }
}

export function groupCountriesByReligion(
  countries: Country[]
): Record<string, Country[]> {
  const groups: Record<string, Country[]> = {}
  countries.forEach((c) => {
    const religion = c.religion.major || 'Unknown'
    if (!groups[religion]) {
      groups[religion] = []
    }
    groups[religion].push(c)
  })
  return groups
}

export function getStatistics(countries: Country[], path: string) {
  const values = countries
    .map((c) => getNestedValue(c as unknown as Record<string, unknown>, path) as number)
    .filter((v) => v !== null && v !== undefined && !isNaN(v))

  if (values.length === 0) {
    return { mean: 0, median: 0, min: 0, max: 0, count: 0 }
  }

  const sorted = [...values].sort((a, b) => a - b)
  const sum = values.reduce((a, b) => a + b, 0)

  return {
    mean: sum / values.length,
    median: sorted[Math.floor(sorted.length / 2)],
    min: sorted[0],
    max: sorted[sorted.length - 1],
    count: values.length,
  }
}
